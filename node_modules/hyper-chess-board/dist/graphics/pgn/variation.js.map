{"version":3,"file":"variation.js","sourceRoot":"","sources":["../../../graphics/pgn/variation.ts"],"names":[],"mappings":"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","sourcesContent":["import { removeGlyphs, Side } from \"../../index.js\";\nimport { Move } from \"../../index.js\";\n\n// the variation object operates as a linked list with a single previous node and a list of next\n// nodes.\n\nexport class VariationMove {\n    public prev?: VariationMove;\n    public next: VariationMove[] = [];\n\n    public level: number = 0;\n    public move?: Move;\n\n    public glyphs: string[] = [];\n    public comment: string = \"\";\n    public fiftyMoveRuleCounter: number = 0;\n\n    constructor(move?: Move, public san?: string){\n        // allows (un)doing the move whenever user scrolls through pgn\n        if (move)\n            this.move = move.clone();\n    }\n\n    // returns the full move number (a \"full move\" being a move from white AND a move from black)\n    public get fullMoveNum(): number {\n        return Math.floor((this.level + 1) / 2);\n    }\n\n    // returns whose turn it is at this variation\n    public get turn(): Side {\n        // to-do: unfortunately level does not decide turn because Black might have\n        // started the game.\n        return this.level % 2 == 1 ? Side.White : Side.Black;\n    }\n\n    // detaches this variation from its previous variation\n    public detach(): void {\n        if (this.prev)\n            this.prev.next.splice(this.prev.next.indexOf(this), 1);\n    }\n\n    // attaches this variation to come after the given variation\n    public attachTo(variation: VariationMove): void {\n        // if necessary, detaches from any previous variation\n        this.detach();\n\n        // sets previous variation\n        this.prev = variation;\n        this.level = variation.level + 1;\n        variation.next.push(this);\n    }\n\n    // finds a common ancestor with another variation node\n    public findCommonAncestor(other: VariationMove): VariationMove {\n        let n1;\n        let n2;\n\n        // n1 will be the node with the greatest level\n        if (this.level > other.level){\n            n1 = this;\n            n2 = other;\n        }else{\n            n1 = other;\n            n2 = this;\n        }\n\n        // search back until the nodes match levels\n        while (n1.level > n2.level){\n            n1 = n1.prev;\n            if (!n1)\n                throw new Error(\"Cannot find a common ancestor of two disconnected nodes\");\n        }\n\n        // keep searching up levels until a common ancestor is found\n        while (n1 != n2){\n            n1 = n1.prev;\n            n2 = n2.prev;\n\n            if (!n1 || !n2)\n                throw new Error(\"Cannot find a common ancestor of two disconnected nodes\");\n        }\n\n        // return the common ancestor\n        return n1;\n    }\n\n    // returns the current variation as text\n    public toText(deleteGlyphs = false): string {\n        let moves = \"\";\n\n        // go back to the first moves and collect them first\n        if (this.prev && this.prev.san){\n            moves += this.prev.toText(deleteGlyphs) + \" \";\n        }\n\n        // append this move after those first moves\n        if (this.san){\n            const san = deleteGlyphs ? removeGlyphs(this.san) : this.san;\n            moves += san;\n        }\n\n        return moves;\n    }\n\n    public isMain(): boolean {\n        // keep traveling backwards until location is not 0 (which means it branches off).\n        // ignores the root\n        let iter: VariationMove | undefined = this;\n        while (iter && iter.prev){\n            if (iter.location != 0)\n                return false;\n            iter = iter.prev;\n        }\n\n        return true;\n    }\n\n    public get location(): number | undefined {\n        if (this.prev)\n            return this.prev.next.indexOf(this);\n        return;\n    }\n}\n"]}