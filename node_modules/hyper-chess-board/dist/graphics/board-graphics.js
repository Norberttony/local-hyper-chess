import { VariationsBoard } from "../game/variations-board.js";
import { setInputTarget } from "./input.js";
import { getFirstElemOfClass, getWidgetLocName } from "./widgets/board-widget.js";
import { setAllPiecesToPool, setAllMoveHighlightsToPool, setAllLastMoveHighlightsToPool, getPieceFromPool, getLastMoveHighlightFromPool, attachGlyph } from "./pool.js";
import { getPieceSide, getPieceType, Side } from "../index.js";
// BoardGraphics has been created to handle the instantiation of a graphical board. The bare minimum
// that it allows is a board element with pieces displayed on it, but it can support any combination
// of widgets, that may listen to relevant state changes.
export class BoardGraphics extends VariationsBoard {
    skeleton;
    boardDiv;
    piecesDiv;
    draggingElem;
    widgets;
    widgetNames = new Set();
    allowInputFrom;
    allowVariations = true;
    piecePointerDown;
    graphicalVariation;
    constructor(allowDragging = true, displayRanksAndFiles = false, skeleton = null) {
        super();
        this.skeleton = createSkeleton(skeleton);
        this.skeleton.classList.add("board-graphics--board-blue", "board-graphics--pieces-cburnett");
        const boardDiv = this.skeleton.getElementsByClassName("board-graphics__board")[0];
        if (!boardDiv)
            throw new Error("Skeleton requires a unique empty div of class name board-graphics__board");
        const piecesDiv = document.createElement("div");
        piecesDiv.classList.add("board-graphics__pieces");
        boardDiv.appendChild(piecesDiv);
        // set attributes
        this.widgets = {};
        this.boardDiv = boardDiv;
        this.piecesDiv = piecesDiv;
        this.allowInputFrom = { [Side.White]: allowDragging, [Side.Black]: allowDragging };
        this.allowVariations = true;
        this.piecePointerDown = createPiecePointerDown(this);
        // graphicalVariation points to the variation currently displayed to the user. If
        // currentVariation does not match with graphicalVariation, applyChanges should be called.
        this.graphicalVariation = this.currentVariation;
        // determine if meant to create files and ranks.
        if (displayRanksAndFiles)
            addFilesAndRanks(boardDiv);
        this.draggingElem = createBoardDraggingElem(this.skeleton);
        if (allowDragging)
            boardDiv.onpointerdown = this.piecePointerDown;
    }
    get isFlipped() {
        return this.skeleton.classList.contains("board-graphics--flipped");
    }
    loading() {
        this.skeleton.classList.add("board-graphics--loading");
    }
    finishedLoading() {
        this.skeleton.classList.remove("board-graphics--loading");
    }
    // retrieves the relevant widget container, creating one if necessary
    getWidgetContainer(location) {
        const widgetLocName = getWidgetLocName(location);
        const elem = getFirstElemOfClass(this.skeleton, `board-graphics__${widgetLocName}`);
        if (elem)
            return elem;
        const w = document.createElement("div");
        w.classList.add(`board-graphics__${widgetLocName}`);
        this.skeleton.appendChild(w);
        return w;
    }
    // expects widgets to be a set of widget names.
    setActiveWidgets(widgets) {
        console.log(Array.from(widgets));
        for (const [name, widget] of Object.entries(this.widgets)) {
            if (widgets.has(name)) {
                widget.enable();
                widgets.delete(name);
            }
            else
                widget.disable();
        }
        console.log(Array.from(widgets));
    }
    attachWidget(widget) {
        const name = widget.constructor.name;
        if (this.widgetNames.has(name)) {
            console.error("Attempted to attach ", name, " as a widget to ", this, " when an instance of this widget is already attached.");
            throw new Error("Tried to attach a widget of the same name to a BoardGraphics instance.");
        }
        this.widgetNames.add(name);
        this.widgets[name] = widget;
    }
    setNames(whiteName, blackName) {
        this.dispatchEvent("player-names", { whiteName, blackName });
    }
    // =========================== //
    // === LOADING FEN AND PGN === //
    // =========================== //
    loadFEN(fen) {
        super.loadFEN(fen);
        this.graphicalVariation = this.variationRoot;
        this.applyChanges(false);
        this.dispatchEvent("loadFEN", { fen });
    }
    loadPGN(pgn) {
        super.loadPGN(pgn);
        const w = this.pgnData.headers.White;
        const b = this.pgnData.headers.Black;
        if (w && b)
            this.setNames(w, b);
        this.applyChanges(false);
    }
    // =========================== //
    // === HANDLING VARIATIONS === //
    // =========================== //
    applyChanges(userInput = false) {
        this.display();
        const cv = this.currentVariation;
        const gv = this.graphicalVariation;
        // no variation changes!
        if (cv == gv)
            return;
        // check if one of the variations follows the other
        if (cv.prev == gv || gv.prev == cv)
            this.dispatchEvent("single-scroll", { prevVariation: gv, variation: cv, userInput });
        this.graphicalVariation = this.currentVariation;
        this.dispatchEvent("variation-change", { variation: cv });
        // apply any relevant glyphs
        if (cv.move) {
            const toX = cv.move.to % 8;
            const toY = Math.floor(cv.move.to / 8);
            // attach any relevant glyphs
            for (const g of cv.glyphs) {
                const pieceElem = this.getPieceElem(toX, toY);
                if (pieceElem)
                    attachGlyph(pieceElem, g);
            }
        }
        // check and dispatch event for any results
        const result = this.isGameOver();
        if (result) {
            this.dispatchEvent("result", {
                turn: this.turn,
                termination: result.termination,
                winner: result.winner
            });
        }
    }
    deleteVariation(variation, isHelper = false) {
        super.deleteVariation(variation, isHelper);
        this.dispatchEvent("delete-variation", { variation });
        this.applyChanges(false);
    }
    // ========================== //
    // === HANDLING MAKE MOVE === //
    // ========================== //
    playMove(move) {
        const variation = super.playMove(move);
        if (variation)
            this.dispatchEvent("new-variation", { variation });
        return variation;
    }
    // returns true if the player can move the piece at the given square. Otherwise, returns false.
    canMove(sq) {
        // ensure user is not creating a variation when not allowed to.
        if (!this.allowVariations && this.currentVariation.next.length > 0)
            return false;
        // prevent user from playing when a result is already set
        if (this.isGameOver())
            return false;
        const piece = this.getPiece(sq);
        const side = getPieceSide(piece);
        return this.allowInputFrom[side] && !this.isImmobilized(sq, piece) && this.turn == side;
    }
    // ============================== //
    // === HANDLING BOARD DISPLAY === //
    // ============================== //
    // if v is false: white perspective
    // if v is true: black perspective
    setFlip(v) {
        if (v != this.isFlipped)
            this.flip();
    }
    // flips the board and then redisplays it
    flip() {
        this.skeleton.classList.toggle("board-graphics--flipped");
        this.display();
        this.dispatchEvent("flip", {});
    }
    display() {
        setAllPiecesToPool(this.skeleton);
        setAllMoveHighlightsToPool(this.skeleton);
        setAllLastMoveHighlightsToPool(this.skeleton);
        const lastMove = this.currentVariation != this.variationRoot ? this.currentVariation.move : undefined;
        // highlight move from and move to
        if (lastMove) {
            const toX = lastMove.to % 8;
            const toY = Math.floor(lastMove.to / 8);
            const fromX = lastMove.from % 8;
            const fromY = Math.floor(lastMove.from / 8);
            const sq1 = getLastMoveHighlightFromPool(toX, toY, this.isFlipped);
            const sq2 = getLastMoveHighlightFromPool(fromX, fromY, this.isFlipped);
            this.piecesDiv.appendChild(sq1);
            this.piecesDiv.appendChild(sq2);
        }
        // display all pieces on the board
        for (let r = 0; r < 8; r++) {
            for (let f = 0; f < 8; f++) {
                const v = this.getPiece(r * 8 + f);
                if (v) {
                    const piece = getPieceFromPool(f, r, this.isFlipped, getPieceType(v), getPieceSide(v));
                    this.piecesDiv.appendChild(piece);
                }
            }
        }
    }
    getPieceElem(f, r) {
        return this.piecesDiv.getElementsByClassName(`${f}_${r}`)[0];
    }
    dispatchEvent(name, detail) {
        this.skeleton.dispatchEvent(new CustomEvent(name, { detail }));
    }
}
// external helper functions that are separated to avoid clutter in the constructor.
// they are generally used to populate the skeleton with graphical features.
// creates a graphical skeleton that is meant to contain a chess board's graphics and widgets.
function createSkeleton(skeleton) {
    // skeleton contains all widgets including main board display
    if (!skeleton)
        skeleton = document.createElement("div");
    skeleton.classList.add("board-graphics");
    skeleton.innerHTML = `<div class = "board-graphics__board">
    <div class = "board-graphics__loading">
        <img class = "board-graphics__loading-img" src = "./images/pieces/immobilizer.png">
    </div>
</div>`;
    if (!skeleton.hasAttribute("tabindex"))
        skeleton.setAttribute("tabindex", "-1");
    return skeleton;
}
function addFilesAndRanks(boardDiv) {
    const filesDiv = document.createElement("div");
    filesDiv.classList.add("board-graphics__files");
    for (const c of "abcdefgh") {
        const file = document.createElement("div");
        file.innerText = c;
        filesDiv.appendChild(file);
    }
    boardDiv.appendChild(filesDiv);
    const ranksDiv = document.createElement("div");
    ranksDiv.classList.add("board-graphics__ranks");
    for (let r = 1; r <= 8; r++) {
        const rank = document.createElement("div");
        rank.innerText = r.toString();
        ranksDiv.appendChild(rank);
    }
    boardDiv.appendChild(ranksDiv);
}
function createBoardDraggingElem(skeleton) {
    const drag = document.createElement("div");
    drag.classList.add("board-graphics__dragging");
    skeleton.appendChild(drag);
    return drag;
}
function createPiecePointerDown(gameState) {
    return (event) => {
        setInputTarget(gameState, gameState.draggingElem, event);
    };
}
//# sourceMappingURL=board-graphics.js.map