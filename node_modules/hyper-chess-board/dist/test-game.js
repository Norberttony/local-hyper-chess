import fs from "node:fs";
import pathModule from "node:path";
import { Board } from "./game/board.js";
const perftPath = pathModule.join(".", "perft.json");
let pv = [];
try {
    console.log("[!!!] Only running tests that are <= 50k nodes because the program is slow");
    const testSuite = JSON.parse(fs.readFileSync(perftPath).toString());
    const b = new Board();
    for (const { fen, nodes } of testSuite) {
        b.loadFEN(fen);
        const startFEN = b.getFEN();
        console.log(fen);
        for (const depthStr of Object.keys(nodes)) {
            const depth = parseInt(depthStr);
            const expected = nodes[depthStr];
            if (expected > 50000)
                continue;
            const actual = countMoves(depth, b, pv)[0];
            const finalFENMatch = b.getFEN() == startFEN;
            console.log(actual, expected);
            if (actual != expected)
                throw new Error(`Perft results did not match for fen ${fen} at depth ${depthStr}; final FEN match: ${finalFENMatch}`);
            if (!finalFENMatch)
                throw new Error(`Perft results matched but the final FEN (${b.getFEN()}) did not match the initial FEN ${startFEN}`);
        }
    }
    console.log("Test finished successfully!");
}
catch (err) {
    console.error("An error occurred during testing:", err);
    console.error("Last PV was", pv);
}
function countMoves(depth, board, pv = [], prevMove) {
    if (depth == 0) {
        if (prevMove)
            return [
                1,
                prevMove.captures.length > 0 ? 1 : 0,
                prevMove.captures.length,
                board.isGameOver() && board.isGameOver().termination == "checkmate" ? 1 : 0
            ];
        else
            return [1, 0, 0, 0];
    }
    const counter = [0, 0, 0, 0];
    const moves = board.generateMoves();
    for (const m of moves) {
        const startFEN = board.getFEN();
        board.makeMove(m);
        pv.push(m.lan);
        const res = countMoves(depth - 1, board, pv, m);
        for (let i = 0; i < 4; i++)
            counter[i] += res[i];
        if (!prevMove)
            console.log(m.lan, res[0]);
        board.unmakeMove(m);
        const endFEN = board.getFEN();
        if (startFEN != endFEN) {
            throw new Error(`startFEN does not match with endFEN, PV: ${pv.join(" ")}`);
        }
        pv.pop();
    }
    return counter;
}
//# sourceMappingURL=test-game.js.map