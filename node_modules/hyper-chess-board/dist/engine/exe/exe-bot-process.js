import { spawn } from "node:child_process";
import { BotProcess } from "../abstract/bot-process.js";
export class ExeBotProcess extends BotProcess {
    path;
    broken = "";
    proc;
    constructor(path) {
        super();
        this.path = path;
        this.start();
    }
    get isRunning() {
        if (!this.proc)
            return false;
        else
            return this.proc.exitCode === null && this.proc.signalCode === null;
    }
    // internal function that separates out stdout into complete lines.
    #getLines(stdoutData) {
        // stdout data might have multiple lines, and the last line might be cut off.
        const lines = (this.broken + stdoutData).split("\r\n");
        if (!stdoutData.endsWith("\r\n") || lines[lines.length - 1] == "")
            this.broken = lines.pop();
        for (const l of lines)
            this.readLine(l);
    }
    start() {
        this.proc = spawn(this.path);
        // broken keeps track of "broken" lines (see #getLines)
        this.broken = "";
        this.proc.stdout.on("data", (data) => {
            this.#getLines(data.toString());
        });
        this.proc.on("error", (err) => {
            throw err;
        });
    }
    // kills the process. Must be run when done interacting with the
    // ExeBotProcess instance.
    stop() {
        if (this.proc) {
            this.proc.kill();
            delete this.proc;
        }
    }
    // returns nothing, can error.
    // feeds the command cmd as the engine's input
    // errors if the process is not currently running
    write(cmd) {
        super.write(cmd);
        if (this.proc)
            this.proc.stdin.write(`${cmd}\n`);
        else
            throw new Error("ExeBotProcess: cannot .write(cmd) when the engine process is not running");
    }
}
//# sourceMappingURL=exe-bot-process.js.map