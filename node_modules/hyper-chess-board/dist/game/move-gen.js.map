{"version":3,"file":"move-gen.js","sourceRoot":"","sources":["../../game/move-gen.ts"],"names":[],"mappings":"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","sourcesContent":["import { arePiecesSameSide, getPieceType, isPieceOfSide, isPieceOfType, Piece, PieceType, Side } from \"./piece.js\";\nimport { RawBoard } from \"./raw-board.js\";\nimport { Move } from \"./move.js\";\nimport { numSquaresToEdge, dirOffsets } from \"./pre-game.js\";\nimport { getRankFromSq, getFileFromSq } from \"./coords.js\";\n\n// Contains all of the code responsible for legal move generation.\n\nexport class MoveGenerator extends RawBoard {\n    constructor(){\n        super();\n    }\n\n    // returns true if a certain square is attacked\n    public isAttacked(sq: number){\n        // go through every move\n        const test = this.generateMoves(false);\n        for (const m of test){\n            for (const c of m.captures){\n                if (c.sq == sq)\n                    return true;\n            }\n        }\n\n        return false;\n    }\n\n    // detects which piece this is, and generates moves for it. Generally used for graphical side of app.\n    public generatePieceMoves(start: number, piece: Piece, filter = true, moves: Move[] = []): Move[] {\n        if (isPieceOfSide(piece, this.turn)){\n            switch(getPieceType(piece)){\n                case PieceType.Straddler:\n                    this.generateStraddlerMoves(start, piece, moves);\n                    break;\n                case PieceType.Coordinator:\n                    this.generateCoordinatorMoves(start, piece, moves);\n                    break;\n                case PieceType.Springer:\n                    this.generateSpringerMoves(start, piece, moves);\n                    break;\n                case PieceType.Retractor:\n                    this.generateRetractorMoves(start, piece, moves);\n                    break;\n                case PieceType.Immobilizer:\n                    this.generateImmobilizerMoves(start, piece, moves);\n                    break;\n                case PieceType.Chameleon:\n                    this.generateChameleonMoves(start, piece, moves);\n                    break;\n                case PieceType.King:\n                    this.generateKingMoves(start, piece, moves);\n                    break;\n            }\n        }\n\n        if (filter)\n            return this.filterLegalMoves(moves);\n        else\n            return moves;\n    }\n\n    // generates all possible moves for the given turn\n    public generateMoves(filter = true): Move[] {\n        const moves: Move[] = [];\n\n        for (let s = 0; s < 64; s++){\n            const piece = this.getPiece(s);\n            this.generatePieceMoves(s, piece, false, moves);\n        }\n\n        if (filter)\n            return this.filterLegalMoves(moves);\n\n        return moves;\n    }\n\n    public generateChameleonMoves(start: number, piece: Piece, moves: Move[]): void {\n        if (this.isImmobilized(start, piece))\n            return;\n\n        // for copying coordinator moves\n        const enemyCoordSq = this.coordinators[this.turn == Side.White ? 1 : 0]!;\n        const enemyCoordRank = getRankFromSq(enemyCoordSq);\n        const enemyCoordFile = getFileFromSq(enemyCoordSq);\n\n        const kingSq = this.getKingSq(false);\n        const kingRank = getRankFromSq(kingSq);\n        const kingFile = getFileFromSq(kingSq);\n\n        // for copying king moves\n        const coordSq = this.coordinators[this.turn == Side.White ? 0 : 1]!;\n        const coordRank = getRankFromSq(coordSq);\n        const coordFile = getFileFromSq(coordSq);\n\n        const enemyKingSq = this.getKingSq(true);\n        const enemyKingRank = getRankFromSq(enemyKingSq);\n        const enemyKingFile = getFileFromSq(enemyKingSq);\n\n        // determines number of valid directions the piece can go through\n        for (let i = 0; i < 8; i++){\n            // goes through all squares until it hits an edge\n            for (let j = 0; j < numSquaresToEdge[start]![i]!; j++){\n\n                const target = start + dirOffsets[i]! * (j + 1);\n                const targetValue = this.getPiece(target);\n\n                const captures = [];\n\n                // check coordinator type moves\n                // checking for targetValue == 0 is fine because a coordinator cannot make a\n                // capturing move that occupies the enemy's square.\n                if (targetValue == 0 && kingSq != 255 && enemyCoordSq != 255){\n                    const targetRank = getRankFromSq(target);\n                    const targetFile = getFileFromSq(target);\n                    if (kingRank == enemyCoordRank && targetFile == enemyCoordFile || kingFile == enemyCoordFile && targetRank == enemyCoordRank){\n                        captures.push({ sq: enemyCoordSq, captured: this.getPiece(enemyCoordSq) });\n                    }\n                }\n\n                // check retractor type moves\n                if (targetValue == 0 && j == 0){\n                    // check backwards\n                    let d = (i + 2) % 4;\n                    if (i >= 4)\n                        d += 4;\n\n                    if (numSquaresToEdge[start]![d]! > 0){\n                        const deathSq = start + dirOffsets[d]!;\n                        const deathVal = this.getPiece(deathSq);\n                        if (deathVal != 0 && !arePiecesSameSide(piece, deathVal) && isPieceOfType(deathVal, PieceType.Retractor)){\n                            captures.push({sq: deathSq, captured: deathVal});\n                        }\n                    }\n                }\n\n                // check king type moves\n                if (targetValue != 0 && j == 0 && !arePiecesSameSide(piece, targetValue) && isPieceOfType(targetValue, PieceType.King)){\n                    // this would cause problems if the king was not a royal piece. but it is :)\n                    moves.push(new Move(target, start, [{ sq: target, captured: targetValue }]));\n                    break;\n                }\n\n                // check springer type moves\n                if (targetValue != 0 && !arePiecesSameSide(piece, targetValue) && isPieceOfType(targetValue, PieceType.Springer) && numSquaresToEdge[target]![i]! > 0 && this.getPiece(target + dirOffsets[i]!) == 0){\n                    // there is actually no way for this move to be covered because of the rules :)\n                    moves.push(new Move(target + dirOffsets[i]!, start, [{ sq: target, captured: targetValue }]));\n                    break;\n                }\n\n                // king type moves, where chameleon acts like king and teams up with own coordinator\n                if (targetValue == 0 && j == 0 && coordSq != 255){\n                    const targetRank = getRankFromSq(target);\n                    const targetFile = getFileFromSq(target);\n\n                    if (targetRank == enemyKingRank && coordFile == enemyKingFile || targetFile == enemyKingFile && coordRank == enemyKingRank){\n                        captures.push({ sq: enemyKingSq, captured: this.getPiece(enemyKingSq) });\n                    }\n                }\n\n                // straddler type moves\n                if (targetValue == 0 && i < 4){\n                    for (let k = -1; k <= 1; k++){\n                        const d = (i + 4 + k) % 4;\n\n                        if (numSquaresToEdge[target]![d]! <= 1)\n                            continue;\n\n                        const nextTarget = target + dirOffsets[d]!;\n                        const nextTargetValue = this.getPiece(nextTarget);\n\n                        if (!arePiecesSameSide(piece, nextTargetValue) && isPieceOfType(nextTargetValue, PieceType.Straddler)){\n                            const nextNextTarget = target + 2 * dirOffsets[d]!;\n                            const nextNextTargetValue = this.getPiece(nextNextTarget);\n\n                            if (arePiecesSameSide(piece, nextNextTargetValue) && (isPieceOfType(nextNextTargetValue, PieceType.Chameleon) || isPieceOfType(nextNextTargetValue, PieceType.Straddler))){\n                                captures.push({ sq: nextTarget, captured: nextTargetValue });\n                            }\n                        }\n                    }\n                }\n\n                if (targetValue == 0)\n                    moves.push(new Move(target, start, captures));\n                else\n                    break;\n\n            }\n        }\n    }\n\n    public generateImmobilizerMoves(start: number, piece: Piece, moves: Move[]): void {\n        if (this.isImmobilized(start, piece))\n            return;\n\n        const dirStart = 0;\n        const dirEnd = 8;\n    \n        // determines number of valid directions the piece can go through\n        for (let i = dirStart; i < dirEnd; i++){\n            // goes through all squares until it hits an edge\n            for (let j = 0; j < numSquaresToEdge[start]![i]!; j++){\n                const target = start + dirOffsets[i]! * (j + 1);\n                const targetValue = this.getPiece(target);\n\n                if (targetValue == 0){\n                    moves.push(new Move(target, start));\n                }else{\n                    break;\n                }\n            }\n        }\n    }\n\n    public generateRetractorMoves(start: number, piece: Piece, moves: Move[]): void {\n        if (this.isImmobilized(start, piece))\n            return;\n\n        const dirStart = 0;\n        const dirEnd = 8;\n    \n        // determines number of valid directions the piece can go through\n        for (let i = dirStart; i < dirEnd; i++){\n            // goes through all squares until it hits an edge\n            for (let j = 0; j < numSquaresToEdge[start]![i]!; j++){\n\n                const target = start + dirOffsets[i]! * (j + 1);\n                const targetValue = this.getPiece(target);\n\n                const captures = [];\n                if (targetValue == 0 && j == 0){\n                    // check backwards\n                    let d = (i + 2) % 4;\n                    if (i >= 4)\n                        d += 4;\n\n                    if (numSquaresToEdge[start]![d]! > 0){\n                        const deathSq = start + dirOffsets[d]!;\n                        const deathVal = this.getPiece(deathSq);\n                        if (deathVal != 0 && !arePiecesSameSide(piece, deathVal))\n                            captures.push({ sq: deathSq, captured: deathVal });\n                    }\n                }\n                \n                if (targetValue != 0)\n                    break;\n\n                moves.push(new Move(target, start, captures));\n            }\n        }\n    }\n\n    public generateSpringerMoves(start: number, piece: Piece, moves: Move[]): void {\n        if (this.isImmobilized(start, piece))\n            return;\n\n        // moves like a chess queen\n        for (let i = 0; i < 8; i++){\n            // goes through all squares until it hits an edge\n            for (let j = 0; j < numSquaresToEdge[start]![i]!; j++){\n\n                const target = start + dirOffsets[i]! * (j + 1);\n                const targetValue = this.getPiece(target);\n\n                if (targetValue != 0){\n\n                    if (arePiecesSameSide(piece, targetValue))\n                        break;\n\n                    if (numSquaresToEdge[target]![i] == 0)\n                        continue;\n\n                    const nextTarget = target + dirOffsets[i]!;\n                    const nextTargetValue = this.getPiece(nextTarget);\n\n                    if (nextTargetValue == 0){\n                        // jump over piece\n                        moves.push(new Move(nextTarget, start, [ { sq: target, captured: targetValue } ]));\n                    }\n                    break;\n\n                }else{\n                    moves.push(new Move(target, start));\n                }\n            }\n        }\n    }\n\n    public generateCoordinatorMoves(start: number, piece: Piece, moves: Move[]): void {\n        if (this.isImmobilized(start, piece))\n            return;\n\n        const dirStart = 0;\n        const dirEnd = 8;\n\n        // a chameleon cannot team up with another chameleon to capture the king.\n        // that would make two chameleons much too powerful :)\n        const considerSquares: number[] = [\n            this.getKingSq(false),\n            this.chameleons[this.turn == Side.White ? 0 : 2]!,\n            this.chameleons[this.turn == Side.White ? 1 : 3]!\n        ].filter(val => val != 255);\n\n        // determines number of valid directions the piece can go through\n        for (let i = dirStart; i < dirEnd; i++){\n            // goes through all squares until it hits an edge\n            for (let j = 0; j < numSquaresToEdge[start]![i]!; j++){\n\n                const target = start + dirOffsets[i]! * (j + 1);\n                const targetValue = this.getPiece(target);\n\n                if (targetValue != 0)\n                    break;\n\n                const rank = getRankFromSq(target);\n                const file = getFileFromSq(target);\n\n                let captures = [];\n                for (let s = 0; s < considerSquares.length; s++){\n                    const sq = considerSquares[s]!;\n                    const sqRank = getRankFromSq(sq)!;\n                    const sqFile = getFileFromSq(sq)!;\n                    if (sqRank != rank && sqFile != file){\n                        // death squares are formed\n                        const death1 = rank * 8 + sqFile;\n                        const death1Value = this.getPiece(death1);\n                        const death2 = sqRank * 8 + file;\n                        const death2Value = this.getPiece(death2);\n\n                        if (death1Value && !arePiecesSameSide(piece, death1Value)){\n                            // if chameleon, must be capturing a king\n                            if (s == 0 || s > 0 && isPieceOfType(death1Value, PieceType.King))\n                                captures.push({ sq: death1, captured: death1Value });\n                        }\n                        if (death2Value && !arePiecesSameSide(piece, death2Value)){\n                            // if chameleon, must be capturing a king\n                            if (s == 0 || s > 0 && isPieceOfType(death2Value, PieceType.King))\n                                captures.push({ sq: death2, captured: death2Value });\n                        }\n                    }\n                }\n\n                moves.push(new Move(target, start, captures));\n            }\n        }\n    }\n\n    public generateStraddlerMoves(start: number, piece: Piece, moves: Move[]): void {\n        if (this.isImmobilized(start, piece))\n            return;\n\n        // determines number of valid directions the piece can go through\n        let canMoveForward = false;\n        for (let i = 0; i < 4; i++){\n            // goes through all squares until it hits an edge\n            for (let j = 0; j < numSquaresToEdge[start]![i]!; j++){\n\n                const target = start + dirOffsets[i]! * (j + 1);\n                const targetValue = this.getPiece(target);\n\n                if (targetValue != 0)\n                    break;\n\n                // straddler can now capture a piece ahead of it, to its left, or to its right (relative to movement)\n                const captures = [];\n                for (let k = -1; k <= 1; k++){\n                    const d = (i + 4 + k) % 4;\n\n                    const nextTarget = target + dirOffsets[d]!;\n                    const nextTargetValue = this.getPiece(nextTarget);\n\n                    if (numSquaresToEdge[target]![d]! <= 1){\n                        if (nextTargetValue == 0)\n                            canMoveForward = true;\n                        continue;\n                    }\n\n                    const nextNextTarget = target + dirOffsets[d]! * 2;\n                    const nextNextTargetValue = this.getPiece(nextNextTarget);\n\n                    // must have a center target and a straddler on the other side for the...\n                    // CUSTODIAN CAPTURE.\n                    // If any of the encompassing pieces are chameleons, the captured piece must also be a straddler.\n                    // must be some of the ugliest code in the whole while world :)\n                    const chameleonCapt = isPieceOfType(nextNextTargetValue, PieceType.Chameleon);\n                    const canCapture = chameleonCapt && isPieceOfType(nextTargetValue, PieceType.Straddler) || !chameleonCapt && isPieceOfType(nextNextTargetValue, PieceType.Straddler);\n                    if (nextTargetValue != 0 && !arePiecesSameSide(piece, nextTargetValue) && arePiecesSameSide(nextNextTargetValue, piece) && canCapture){\n                        captures.push({sq: nextTarget, captured: nextTargetValue});\n                    }else if (nextTargetValue == 0 && k == 0){\n                        canMoveForward = true;\n                    }\n                }\n\n                moves.push(new Move(target, start, captures));\n\n                if (!canMoveForward){\n                    break;\n                }\n            }\n        }\n    }\n\n    // generates moves for a king\n    public generateKingMoves(start: number, piece: Piece, moves: Move[]): void {\n        if (this.isImmobilized(start, piece))\n            return;\n\n        // king can team up with its own coordinator to create death squares\n        const coordSq = this.getCoordSq(false);\n        const coordRank = getRankFromSq(coordSq);\n        const coordFile = getFileFromSq(coordSq);\n\n        // see if king can team up with chameleon and capture an enemy coordinator!\n        const enemyCoordSq = this.getCoordSq(true);\n        const enemyCoordRank = getRankFromSq(enemyCoordSq);\n        const enemyCoordFile = getFileFromSq(enemyCoordSq);\n\n        // check all directions\n        for (let i = 0; i < dirOffsets.length; i++){\n            if (numSquaresToEdge[start]![i]! > 0){\n\n                const target = start + dirOffsets[i]!;\n                const targetValue = this.getPiece(target);\n\n                if (targetValue != 0 && arePiecesSameSide(piece, targetValue)){\n                    continue;\n                }\n\n                const rank = getRankFromSq(target);\n                const file = getFileFromSq(target);\n\n                const captures = [];\n                if (coordSq != 255 && coordRank != rank && coordFile != file){\n                    // death squares are formed\n                    const death1 = rank * 8 + coordFile;\n                    const death1Value = this.getPiece(death1);\n                    const death2 = coordRank * 8 + file;\n                    const death2Value = this.getPiece(death2);\n\n                    if (death1Value && !arePiecesSameSide(piece, death1Value)){\n                        captures.push({ sq: death1, captured: death1Value });\n                    }\n                    if (death2Value && !arePiecesSameSide(piece, death2Value)){\n                        captures.push({ sq: death2, captured: death2Value });\n                    }\n                }\n\n                // test for king-chameleon death squares\n                if (enemyCoordSq != 255){\n                    const thisRank = getRankFromSq(target);\n                    const thisFile = getFileFromSq(target);\n\n                    const chamStart = this.turn == Side.White ? 0 : 2;\n                    const chamEnd = this.turn == Side.White ? 2 : 4;\n                    for (let i = chamStart; i < chamEnd; i++){\n                        if (this.chameleons[i] == 255)\n                            break;\n\n                        const rank = getRankFromSq(this.chameleons[i]!);\n                        const file = getFileFromSq(this.chameleons[i]!);\n\n                        // forms death squares, but only against the enemy coordinator.\n                        // and there's always only one enemy coordinator.\n                        // of course, the king isn't actually forming chameleon death squares if the two are aligned (rank/file)\n                        if (rank == enemyCoordRank && thisFile == enemyCoordFile && thisFile != file && thisRank != rank){\n                            captures.push({ sq: enemyCoordSq, captured: this.getPiece(enemyCoordSq) });\n                            break;\n                        }\n                        if (file == enemyCoordFile && thisRank == enemyCoordRank && thisFile != file && thisRank != rank){\n                            captures.push({ sq: enemyCoordSq, captured: this.getPiece(enemyCoordSq) });\n                            break;\n                        }\n                    }\n                }\n\n                if (targetValue != 0 && !arePiecesSameSide(piece, targetValue)){\n                    captures.push({ sq: target, captured: targetValue });\n                }\n\n                moves.push(new Move(target, start, captures));\n            }\n        }\n    }\n\n    // takes in a list of moves, and gives a list of all legal moves\n    public filterLegalMoves(moves: Move[]): Move[] {\n        return moves.filter((move) => this.isMoveLegal(move));\n    }\n\n    // checks if a move is legal\n    public isMoveLegal(move: Move): boolean {\n        this.makeMove(move);\n\n        // if the move causes the current king to stay in check, then it can't be legal\n        const attacksKing = this.isAttacked(this.getKingSq(true));\n\n        this.unmakeMove(move);\n\n        return !attacksKing;\n    }\n\n    // performs a move on the board. this method assumes that the given move is LEGAL\n    // if the move is not legal, then some funny behavior could occur.\n    public makeMove(move: Move): void {\n        // update halfmove counter\n        this.halfmoves.unshift(this.halfmoves[0]! + 1);\n        if (move.captures.length > 0)\n            this.halfmoves[0] = 0;\n\n        // go through all of the captures\n        for (const { sq } of move.captures)\n            this.pickup(sq);\n\n        // moves the piece to its designated square, leaving nothing behind\n        this.placedown(move.to, this.pickup(move.from));\n        \n        // fullmove\n        if (isPieceOfSide(this.turn, Side.Black)){\n            this.fullmove++;\n        }\n\n        // set turn\n        this.nextTurn();\n    }\n\n    // un-does a move on the board (make sure that the move being undone is the most recent made move)\n    public unmakeMove(move: Move): void {\n        // update halfmove counter\n        this.halfmoves.shift();\n\n        // unmove the piece and uncapture whatever it captured.\n        this.placedown(move.from, this.pickup(move.to));\n        for (const { sq, captured } of move.captures)\n            this.placedown(sq, captured);\n\n        // set turn\n        this.nextTurn();\n\n        // fullmove\n        if (isPieceOfSide(this.turn, Side.Black)){\n            this.fullmove--;\n        }\n    }\n    // ==== END MOVE GENERATION AND CHECKING ==== //\n}\n"]}