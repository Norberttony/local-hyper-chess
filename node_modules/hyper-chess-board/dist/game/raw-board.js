import { squareToAlgebraic } from "./coords.js";
import { PieceType, Side, isPieceOfSide, getPieceType, isPieceOfType, getPieceSide, getFENCharFromPieceType, getPieceFromFENChar, arePiecesSameSide } from "./piece.js";
import { numSquaresToEdge, dirOffsets } from "./pre-game.js";
// the base board with no move-gen functionality. The only reason this class
// exists is to separate the move generator from generic board operations, such
// as checking where pieces are.
export class RawBoard {
    // contains the type and side of every piece on all 64 squares (Side | PieceType)
    squares = new Uint8Array(64);
    pieceCounts = [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]];
    turn = Side.White;
    // quick look-ups for piece squares (first index is white second is black)
    kings = new Uint8Array(2);
    coordinators = new Uint8Array(2);
    chameleons = new Uint8Array(4);
    fullmove = 1;
    // keeps track of the history of halfmoves (to allow for undoing moves)
    halfmoves = [];
    constructor() { }
    getFullMove() {
        return this.fullmove;
    }
    getTurn() {
        return this.turn;
    }
    getPieceCount(p) {
        return this.pieceCounts[isPieceOfSide(p, Side.White) ? 0 : 1][getPieceType(p)];
    }
    getPiece(sq) {
        return this.squares[sq];
    }
    // picks up the piece at the sq
    // returns the value of the picked up piece
    pickup(sq) {
        const val = this.getPiece(sq);
        if (val == 0)
            return 0;
        this.squares[sq] = 0;
        const isWhite = isPieceOfSide(val, Side.White);
        this.pieceCounts[isWhite ? 0 : 1][getPieceType(val)]--;
        // update piece square look ups
        if (isPieceOfType(val, PieceType.Coordinator)) {
            // remove coordinator from list
            this.coordinators[getPieceSide(val) / 8 - 1] = 255;
        }
        else if (isPieceOfType(val, PieceType.Chameleon)) {
            // remove chameleon from list
            if (isWhite) {
                if (this.chameleons[0] == sq) {
                    this.chameleons[0] = this.chameleons[1];
                    this.chameleons[1] = 255;
                }
                else if (this.chameleons[1] == sq)
                    this.chameleons[1] = 255;
                else {
                    console.log("white", this.getFEN(), this.chameleons);
                    throw new Error(`Tried to pick up a chameleon on ${squareToAlgebraic(sq)} but it was never stored in the lookup`);
                }
            }
            else {
                if (this.chameleons[2] == sq) {
                    this.chameleons[2] = this.chameleons[3];
                    this.chameleons[3] = 255;
                }
                else if (this.chameleons[3] == sq)
                    this.chameleons[3] = 255;
                else {
                    console.log("black", this.getFEN(), this.chameleons);
                    throw new Error(`Tried to pick up a chameleon on ${squareToAlgebraic(sq)} but it was never stored in the lookup`);
                }
            }
        }
        else if (isPieceOfType(val, PieceType.King)) {
            if (isWhite) {
                this.kings[0] = 255;
            }
            else {
                this.kings[1] = 255;
            }
        }
        return val;
    }
    // places down the given piece at the sq
    // assumes that there is currently no piece at the given sq.
    placedown(sq, piece) {
        if (this.squares[sq])
            return;
        this.squares[sq] = piece;
        const isWhite = isPieceOfSide(piece, Side.White);
        this.pieceCounts[isWhite ? 0 : 1][getPieceType(piece)]++;
        // update piece square look ups
        if (isPieceOfType(piece, PieceType.Coordinator)) {
            const idx = getPieceSide(piece) / 8 - 1;
            if (this.coordinators[idx] == 255)
                this.coordinators[idx] = sq;
            else
                throw new Error("Cannot have more than 1 coordinator on one side in a position");
        }
        else if (isPieceOfType(piece, PieceType.Chameleon)) {
            if (isWhite) {
                if (this.chameleons[0] == 255)
                    this.chameleons[0] = sq;
                else if (this.chameleons[1] == 255)
                    this.chameleons[1] = sq;
                else {
                    console.log("white", this.getFEN(), this.chameleons, sq);
                    throw new Error("Cannot have more than 2 chameleons on one side in a position");
                }
            }
            else {
                if (this.chameleons[2] == 255)
                    this.chameleons[2] = sq;
                else if (this.chameleons[3] == 255)
                    this.chameleons[3] = sq;
                else {
                    console.log("black", this.getFEN(), this.chameleons, sq);
                    throw new Error("Cannot have more than 2 chameleons on one side in a position");
                }
            }
        }
        else if (isPieceOfType(piece, PieceType.King)) {
            if (isWhite) {
                if (this.kings[0] != 255)
                    throw new Error("Cannot have more than 1 king on one side in a position");
                this.kings[0] = sq;
            }
            else {
                if (this.kings[1] != 255)
                    throw new Error("Cannot have more than 1 king on one side in a position");
                this.kings[1] = sq;
            }
        }
    }
    // returns any unique identifiers to a position (arrangement of pieces and whose turn it is)
    getPosition() {
        return `${this.squares.join(".")}.${this.turn}`;
    }
    // returns true if the given pieceType is within a 1 square in any direction to the given sq
    // AND if that piece is of opposite color to the given piece.
    inVicinity(sq, piece, pieceType) {
        // go through all 8 directions
        for (let i = 0; i < 8; i++) {
            // prevent wrapping around board
            if (numSquaresToEdge[sq][i] == 0)
                continue;
            const target = sq + dirOffsets[i];
            const targetValue = this.getPiece(target);
            if (isPieceOfType(targetValue, pieceType) && !arePiecesSameSide(piece, targetValue)) {
                return true;
            }
        }
        return false;
    }
    // returns true if a given piece is within the sphere of influence of an enemy immobilizer.
    isImmobilized(sq, piece) {
        if (this.inVicinity(sq, piece, PieceType.Immobilizer))
            return true;
        if (isPieceOfType(piece, PieceType.Immobilizer))
            return this.inVicinity(sq, piece, PieceType.Chameleon);
        return false;
    }
    // retrieves the square of the king
    getKingSq(enemy) {
        return this.kings[this.turn == (enemy ? Side.Black : Side.White) ? 0 : 1];
    }
    // retrieves the square of the coordinator
    getCoordSq(enemy) {
        return this.coordinators[this.turn == (enemy ? Side.Black : Side.White) ? 0 : 1];
    }
    nextTurn() {
        this.turn = this.turn == Side.White ? Side.Black : Side.White;
    }
    // loads a FEN into this board state
    loadFEN(fen) {
        // clear board first
        this.squares = new Uint8Array(64);
        this.coordinators[0] = 255;
        this.coordinators[1] = 255;
        this.chameleons[0] = 255;
        this.chameleons[1] = 255;
        this.chameleons[2] = 255;
        this.chameleons[3] = 255;
        this.kings[0] = 255;
        this.kings[1] = 255;
        this.pieceCounts = [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]];
        // 0 = board state
        // 1 = turn
        // 2 = fullmove number (number of fullmoves, starts at 1, incremented after black's move)
        let segments = fen.split(" ");
        // rewrite board state
        let state = segments[0];
        let f = 0;
        let r = 7;
        for (let i = 0; i < state.length; i++) {
            let c = state[i];
            if (c == "/") {
                r--;
                f = 0;
            }
            else if (getPieceFromFENChar(c)) {
                let piece = getPieceFromFENChar(c);
                let sq = f + r * 8;
                this.squares[sq] = piece;
                f++;
                const isWhite = isPieceOfSide(piece, Side.White);
                this.pieceCounts[isWhite ? 0 : 1][getPieceType(piece)]++;
                // if the piece is a king, record it
                if (isPieceOfType(piece, PieceType.King)) {
                    isWhite ? this.kings[0] = sq : this.kings[1] = sq;
                }
                // if the piece is a coordinator, record it
                if (isPieceOfType(piece, PieceType.Coordinator)) {
                    isWhite ? this.coordinators[0] = sq : this.coordinators[1] = sq;
                }
                if (isPieceOfType(piece, PieceType.Chameleon)) {
                    if (isWhite) {
                        if (this.chameleons[0] == 255) {
                            this.chameleons[0] = sq;
                        }
                        else {
                            this.chameleons[1] = sq;
                        }
                    }
                    else {
                        if (this.chameleons[2] == 255) {
                            this.chameleons[2] = sq;
                        }
                        else {
                            this.chameleons[3] = sq;
                        }
                    }
                }
            }
            else {
                f += parseInt(c);
            }
        }
        // set proper turn
        if (segments[1].toLowerCase() == "w") {
            this.turn = Side.White;
        }
        else {
            this.turn = Side.Black;
        }
        // halfmove clock
        this.halfmoves = [parseInt(segments[2]) || 0];
        // fullmove clock
        this.fullmove = parseInt(segments[3]);
        if (isNaN(this.fullmove))
            this.fullmove = 1;
    }
    getFEN() {
        let FEN = "";
        // write board state into FEN
        for (let r = 7; r >= 0; r--) {
            let empty = 0;
            for (let f = 0; f < 8; f++) {
                let v = this.squares[f + r * 8];
                if (v) {
                    if (empty)
                        FEN += empty;
                    empty = 0;
                    let pieceFEN = getFENCharFromPieceType(getPieceType(v));
                    FEN += isPieceOfSide(v, Side.White) ? pieceFEN.toUpperCase() : pieceFEN.toLowerCase();
                }
                else {
                    empty++;
                }
            }
            if (empty)
                FEN += empty;
            FEN += "/";
        }
        FEN = FEN.substring(0, FEN.length - 1);
        // set proper turn
        let turn = this.turn == Side.White ? "w" : "b";
        FEN += ` ${turn} ${this.halfmoves[0]} ${this.fullmove}`;
        return FEN;
    }
}
//# sourceMappingURL=raw-board.js.map