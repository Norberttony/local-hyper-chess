{"version":3,"file":"board.js","sourceRoot":"","sources":["../../game/board.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n    AlgebraicSquare,\n    algebraicToSquare, squareToAlgebraic,\n    squareToAlgebraicFile, squareToAlgebraicRank\n} from \"./coords.js\";\nimport { arePiecesSameType, getPieceSide, getPieceType, getPieceFromFENChar, getSANCharFromPieceType, isPieceOfType, PieceType, Side } from \"./piece.js\";\nimport { numSquaresToEdge, dirOffsets } from \"./pre-game.js\";\nimport { removeGlyphs } from \"./san.js\";\nimport { MoveGenerator } from \"./move-gen.js\";\nimport { Move } from \"./move.js\";\n\n// contains all of the game logic\n\n// this code REPEATEDLY violates the DRY principle. read at your own risk.\n\nexport const StartingFEN = \"unbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNU w 0 1\";\n\nexport interface GameResult {\n    termination: string,\n    winner: Side\n};\n\n// The Board object contains a game state of the board. Certain moves can be done or undone, but\n// they are not stored.\nexport class Board extends MoveGenerator {\n    private result?: GameResult;\n    private repeats: { [pos: string]: number } = {};\n\n    constructor(fen = StartingFEN){\n        super();\n        Board.prototype.loadFEN.call(this, fen);\n    }\n\n    public override loadFEN(fen: string): void {\n        super.loadFEN(fen);\n        this.repeats = {\n            [this.getPosition()]: 1\n        };\n        delete this.result;\n    }\n\n    protected setResult(termination: string, winner: Side): GameResult {\n        this.result = { termination, winner };\n        return this.result;\n    }\n\n    public override makeMove(move: Move): void {\n        super.makeMove(move);\n\n        const pos = this.getPosition();\n        const reps = (this.repeats[pos] || 0) + 1;\n        this.repeats[pos] = reps;\n        if (reps >= 3)\n            this.setResult(\"threefold\", Side.None);\n\n        if (this.halfmoves[0]! >= 100)\n            this.setResult(\"fifty move rule\", Side.None);\n    }\n\n    public override unmakeMove(move: Move): void {\n        const pos = this.getPosition();\n        this.repeats[pos]!--;\n\n        super.unmakeMove(move);\n        delete this.result;\n    }\n\n    // checks if the current player is checkmated... or stalemated...\n    public isGameOver(moves?: Move[]): GameResult | undefined {\n        if (this.result)\n            return this.result;\n\n        if (!moves)\n            moves = this.generateMoves();\n\n        // no legal moves?!\n        if (moves.length == 0){\n            this.nextTurn();\n            if (this.isAttacked(this.getKingSq(true))){\n                // CHECKMATE!!!\n                this.setResult(\"checkmate\", this.turn);\n            }else{\n                // stalemate...!\n                this.setResult(\"stalemate\", Side.None);\n            }\n            this.nextTurn();\n        }else{\n            // determine if it is a draw by insufficient material\n            let sufficient = false;\n            for (let i = PieceType.King; i <= PieceType.Immobilizer; i++){\n                if (i == PieceType.King || i == PieceType.Straddler)\n                    continue;\n                if (this.getPieceCount(Side.White | i) != 0 || this.getPieceCount(Side.Black | i) != 0){\n                    sufficient = true;\n                    break;\n                }\n            }\n\n            if (!sufficient){\n                // KvK, KPvK, KPPvK, KPPvKP are all immediate draws.\n                const whiteStraddlerCount = this.getPieceCount(Side.White | PieceType.Straddler);\n                const blackStraddlerCount = this.getPieceCount(Side.Black | PieceType.Straddler);\n                let most = Math.max(whiteStraddlerCount, blackStraddlerCount);\n                let least = Math.min(whiteStraddlerCount, blackStraddlerCount);\n                if (most <= 1 || most == 2 && least <= 1){\n                    // certain draw.\n                    this.setResult(\"insufficient material\", Side.None);\n                }\n            }\n            \n        }\n\n        return this.result;\n    }\n\n    // gets move given SAN\n    public getMoveOfSAN(san: string): Move {\n        // take a short cut by considering the destination square of the san and the move piece's type\n        san = removeGlyphs(san);\n        const toSq = algebraicToSquare(san.substring(san.length - 2) as AlgebraicSquare);\n        const fenChar = this.turn == Side.White ? san[0]! : san[0]!.toLowerCase();\n        const pieceValue = getPieceFromFENChar(fenChar);\n\n        if (toSq < 0 || toSq >= 64 || isNaN(toSq))\n            throw new Error(`Square ${toSq} is out of range`);\n\n        const possibleMoves: Move[] = [];\n        for (let j = 0; j < dirOffsets.length; j++){\n            let blockerCase = isPieceOfType(pieceValue, PieceType.Springer) || isPieceOfType(pieceValue, PieceType.Chameleon) ? 1 : 0;\n            const isCham = isPieceOfType(pieceValue, PieceType.Chameleon);\n            for (let i = 1; i <= numSquaresToEdge[toSq]![j]!; i++){\n                const startSq = toSq + i * dirOffsets[j]!;\n                const val = this.getPiece(startSq);\n                if (val){\n                    if (val == pieceValue){\n                        const pieceMoves = this.generatePieceMoves(startSq, val, false);\n                        for (const m of pieceMoves){\n                            if (m.to == toSq){\n                                possibleMoves.push(m);\n                            }\n                        }\n                    }\n                    if (getPieceSide(pieceValue) != getPieceSide(val)){\n                        if (blockerCase && (!isCham || isPieceOfType(val, PieceType.Springer)))\n                            blockerCase--;\n                        else\n                            break;\n                    }else{\n                        break;\n                    }\n                }\n            }\n        }\n\n        for (const m of possibleMoves){\n            // only consider SAN if to squares and piece types match\n            if (m.to != toSq || this.getPiece(m.from) != pieceValue)\n                continue;\n\n            const SAN = this.getMoveSAN(m, possibleMoves, false);\n            if (removeGlyphs(SAN) == san){\n                return m;\n            }\n        }\n\n        console.error(san, possibleMoves, this.getFEN());\n        throw new Error(`Move of SAN ${san} could not be found.`);\n    }\n\n    public getMoveOfLAN(LAN: string){\n        const moves = this.generateMoves(true);\n\n        for (const m of moves){\n            if (m.lan == LAN){\n                return m;\n            }\n        }\n\n        console.error(\"At position\", this.getFEN());\n        throw new Error(`Cannot find move of lan ${LAN}`);\n    }\n\n    // returns the SAN For the given move\n    public getMoveSAN(move: Move, pseudoMoves = this.generateMoves(false), withGlyphs = true): string {\n        let SAN;\n\n        const movingPiece = this.getPiece(move.from);\n    \n        /* collects information on move collision ambiguity */\n        let sameMove = false;\n        let sameFile = false;\n        let sameRank = false;\n        for (const other of pseudoMoves){\n            if (!(move.from == other.from) && move.to == other.to && arePiecesSameType(movingPiece, this.getPiece(other.from))){\n    \n                // of course, ambiguity is only caused if the move is legal.\n                if (!this.isMoveLegal(other))\n                    continue;\n    \n                // oh no, the move is ambiguous!\n                sameMove = true;\n    \n                // do we need to specify the rank (first & foremost?)\n                if (squareToAlgebraicRank(move.from) == squareToAlgebraicRank(other.from))\n                    sameRank = true;\n                \n                // what about the file\n                if (squareToAlgebraicFile(move.from) == squareToAlgebraicFile(other.from))\n                    sameFile = true;\n            }\n        }\n    \n        let movingPieceType = getPieceType(movingPiece);\n    \n        // using information from move collision ambiguity, determine the resolving square\n        let resolvedSquare = \"\";\n        if (sameMove){\n            if (sameRank || (!sameRank && !sameFile))\n                resolvedSquare += squareToAlgebraicFile(move.from);\n            if (sameFile)\n                resolvedSquare += squareToAlgebraicRank(move.from);\n        }\n\n        const SANChar = getSANCharFromPieceType(movingPieceType);\n        SAN = `${SANChar}${resolvedSquare}${move.captures.length > 0 ? \"x\": \"\"}${squareToAlgebraic(move.to)}`;\n    \n        if (withGlyphs){\n            this.makeMove(move);\n    \n            // is game over?\n            let result = this.isGameOver();\n            if (result && result.termination == \"checkmate\"){\n                SAN += \"#\";\n            }else{\n                // does this move threaten to take the king on the next turn?\n                this.nextTurn();\n                const moves = this.generateMoves(false);\n                this.nextTurn();\n    \n                let isCheck = false;\n                for (const m of moves){\n                    for (const c of m.captures){\n                        if (isPieceOfType(c.captured, PieceType.King)){\n                            isCheck = true;\n                            break;\n                        }\n                    }\n                    if (isCheck)\n                        break;\n                }\n                if (isCheck)\n                    SAN += \"+\";\n            }\n            this.unmakeMove(move);\n        }\n    \n        return SAN;\n    }\n}\n"]}