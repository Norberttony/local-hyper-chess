import { arePiecesSameSide, getPieceType, isPieceOfSide, isPieceOfType, PieceType, Side } from "./piece.js";
import { RawBoard } from "./raw-board.js";
import { Move } from "./move.js";
import { numSquaresToEdge, dirOffsets } from "./pre-game.js";
import { getRankFromSq, getFileFromSq } from "./coords.js";
// Contains all of the code responsible for legal move generation.
export class MoveGenerator extends RawBoard {
    constructor() {
        super();
    }
    // returns true if a certain square is attacked
    isAttacked(sq) {
        // go through every move
        const test = this.generateMoves(false);
        for (const m of test) {
            for (const c of m.captures) {
                if (c.sq == sq)
                    return true;
            }
        }
        return false;
    }
    // detects which piece this is, and generates moves for it. Generally used for graphical side of app.
    generatePieceMoves(start, piece, filter = true, moves = []) {
        if (isPieceOfSide(piece, this.turn)) {
            switch (getPieceType(piece)) {
                case PieceType.Straddler:
                    this.generateStraddlerMoves(start, piece, moves);
                    break;
                case PieceType.Coordinator:
                    this.generateCoordinatorMoves(start, piece, moves);
                    break;
                case PieceType.Springer:
                    this.generateSpringerMoves(start, piece, moves);
                    break;
                case PieceType.Retractor:
                    this.generateRetractorMoves(start, piece, moves);
                    break;
                case PieceType.Immobilizer:
                    this.generateImmobilizerMoves(start, piece, moves);
                    break;
                case PieceType.Chameleon:
                    this.generateChameleonMoves(start, piece, moves);
                    break;
                case PieceType.King:
                    this.generateKingMoves(start, piece, moves);
                    break;
            }
        }
        if (filter)
            return this.filterLegalMoves(moves);
        else
            return moves;
    }
    // generates all possible moves for the given turn
    generateMoves(filter = true) {
        const moves = [];
        for (let s = 0; s < 64; s++) {
            const piece = this.getPiece(s);
            this.generatePieceMoves(s, piece, false, moves);
        }
        if (filter)
            return this.filterLegalMoves(moves);
        return moves;
    }
    generateChameleonMoves(start, piece, moves) {
        if (this.isImmobilized(start, piece))
            return;
        // for copying coordinator moves
        const enemyCoordSq = this.coordinators[this.turn == Side.White ? 1 : 0];
        const enemyCoordRank = getRankFromSq(enemyCoordSq);
        const enemyCoordFile = getFileFromSq(enemyCoordSq);
        const kingSq = this.getKingSq(false);
        const kingRank = getRankFromSq(kingSq);
        const kingFile = getFileFromSq(kingSq);
        // for copying king moves
        const coordSq = this.coordinators[this.turn == Side.White ? 0 : 1];
        const coordRank = getRankFromSq(coordSq);
        const coordFile = getFileFromSq(coordSq);
        const enemyKingSq = this.getKingSq(true);
        const enemyKingRank = getRankFromSq(enemyKingSq);
        const enemyKingFile = getFileFromSq(enemyKingSq);
        // determines number of valid directions the piece can go through
        for (let i = 0; i < 8; i++) {
            // goes through all squares until it hits an edge
            for (let j = 0; j < numSquaresToEdge[start][i]; j++) {
                const target = start + dirOffsets[i] * (j + 1);
                const targetValue = this.getPiece(target);
                const captures = [];
                // check coordinator type moves
                // checking for targetValue == 0 is fine because a coordinator cannot make a
                // capturing move that occupies the enemy's square.
                if (targetValue == 0 && kingSq != 255 && enemyCoordSq != 255) {
                    const targetRank = getRankFromSq(target);
                    const targetFile = getFileFromSq(target);
                    if (kingRank == enemyCoordRank && targetFile == enemyCoordFile || kingFile == enemyCoordFile && targetRank == enemyCoordRank) {
                        captures.push({ sq: enemyCoordSq, captured: this.getPiece(enemyCoordSq) });
                    }
                }
                // check retractor type moves
                if (targetValue == 0 && j == 0) {
                    // check backwards
                    let d = (i + 2) % 4;
                    if (i >= 4)
                        d += 4;
                    if (numSquaresToEdge[start][d] > 0) {
                        const deathSq = start + dirOffsets[d];
                        const deathVal = this.getPiece(deathSq);
                        if (deathVal != 0 && !arePiecesSameSide(piece, deathVal) && isPieceOfType(deathVal, PieceType.Retractor)) {
                            captures.push({ sq: deathSq, captured: deathVal });
                        }
                    }
                }
                // check king type moves
                if (targetValue != 0 && j == 0 && !arePiecesSameSide(piece, targetValue) && isPieceOfType(targetValue, PieceType.King)) {
                    // this would cause problems if the king was not a royal piece. but it is :)
                    moves.push(new Move(target, start, [{ sq: target, captured: targetValue }]));
                    break;
                }
                // check springer type moves
                if (targetValue != 0 && !arePiecesSameSide(piece, targetValue) && isPieceOfType(targetValue, PieceType.Springer) && numSquaresToEdge[target][i] > 0 && this.getPiece(target + dirOffsets[i]) == 0) {
                    // there is actually no way for this move to be covered because of the rules :)
                    moves.push(new Move(target + dirOffsets[i], start, [{ sq: target, captured: targetValue }]));
                    break;
                }
                // king type moves, where chameleon acts like king and teams up with own coordinator
                if (targetValue == 0 && j == 0 && coordSq != 255) {
                    const targetRank = getRankFromSq(target);
                    const targetFile = getFileFromSq(target);
                    if (targetRank == enemyKingRank && coordFile == enemyKingFile || targetFile == enemyKingFile && coordRank == enemyKingRank) {
                        captures.push({ sq: enemyKingSq, captured: this.getPiece(enemyKingSq) });
                    }
                }
                // straddler type moves
                if (targetValue == 0 && i < 4) {
                    for (let k = -1; k <= 1; k++) {
                        const d = (i + 4 + k) % 4;
                        if (numSquaresToEdge[target][d] <= 1)
                            continue;
                        const nextTarget = target + dirOffsets[d];
                        const nextTargetValue = this.getPiece(nextTarget);
                        if (!arePiecesSameSide(piece, nextTargetValue) && isPieceOfType(nextTargetValue, PieceType.Straddler)) {
                            const nextNextTarget = target + 2 * dirOffsets[d];
                            const nextNextTargetValue = this.getPiece(nextNextTarget);
                            if (arePiecesSameSide(piece, nextNextTargetValue) && (isPieceOfType(nextNextTargetValue, PieceType.Chameleon) || isPieceOfType(nextNextTargetValue, PieceType.Straddler))) {
                                captures.push({ sq: nextTarget, captured: nextTargetValue });
                            }
                        }
                    }
                }
                if (targetValue == 0)
                    moves.push(new Move(target, start, captures));
                else
                    break;
            }
        }
    }
    generateImmobilizerMoves(start, piece, moves) {
        if (this.isImmobilized(start, piece))
            return;
        const dirStart = 0;
        const dirEnd = 8;
        // determines number of valid directions the piece can go through
        for (let i = dirStart; i < dirEnd; i++) {
            // goes through all squares until it hits an edge
            for (let j = 0; j < numSquaresToEdge[start][i]; j++) {
                const target = start + dirOffsets[i] * (j + 1);
                const targetValue = this.getPiece(target);
                if (targetValue == 0) {
                    moves.push(new Move(target, start));
                }
                else {
                    break;
                }
            }
        }
    }
    generateRetractorMoves(start, piece, moves) {
        if (this.isImmobilized(start, piece))
            return;
        const dirStart = 0;
        const dirEnd = 8;
        // determines number of valid directions the piece can go through
        for (let i = dirStart; i < dirEnd; i++) {
            // goes through all squares until it hits an edge
            for (let j = 0; j < numSquaresToEdge[start][i]; j++) {
                const target = start + dirOffsets[i] * (j + 1);
                const targetValue = this.getPiece(target);
                const captures = [];
                if (targetValue == 0 && j == 0) {
                    // check backwards
                    let d = (i + 2) % 4;
                    if (i >= 4)
                        d += 4;
                    if (numSquaresToEdge[start][d] > 0) {
                        const deathSq = start + dirOffsets[d];
                        const deathVal = this.getPiece(deathSq);
                        if (deathVal != 0 && !arePiecesSameSide(piece, deathVal))
                            captures.push({ sq: deathSq, captured: deathVal });
                    }
                }
                if (targetValue != 0)
                    break;
                moves.push(new Move(target, start, captures));
            }
        }
    }
    generateSpringerMoves(start, piece, moves) {
        if (this.isImmobilized(start, piece))
            return;
        // moves like a chess queen
        for (let i = 0; i < 8; i++) {
            // goes through all squares until it hits an edge
            for (let j = 0; j < numSquaresToEdge[start][i]; j++) {
                const target = start + dirOffsets[i] * (j + 1);
                const targetValue = this.getPiece(target);
                if (targetValue != 0) {
                    if (arePiecesSameSide(piece, targetValue))
                        break;
                    if (numSquaresToEdge[target][i] == 0)
                        continue;
                    const nextTarget = target + dirOffsets[i];
                    const nextTargetValue = this.getPiece(nextTarget);
                    if (nextTargetValue == 0) {
                        // jump over piece
                        moves.push(new Move(nextTarget, start, [{ sq: target, captured: targetValue }]));
                    }
                    break;
                }
                else {
                    moves.push(new Move(target, start));
                }
            }
        }
    }
    generateCoordinatorMoves(start, piece, moves) {
        if (this.isImmobilized(start, piece))
            return;
        const dirStart = 0;
        const dirEnd = 8;
        // a chameleon cannot team up with another chameleon to capture the king.
        // that would make two chameleons much too powerful :)
        const considerSquares = [
            this.getKingSq(false),
            this.chameleons[this.turn == Side.White ? 0 : 2],
            this.chameleons[this.turn == Side.White ? 1 : 3]
        ].filter(val => val != 255);
        // determines number of valid directions the piece can go through
        for (let i = dirStart; i < dirEnd; i++) {
            // goes through all squares until it hits an edge
            for (let j = 0; j < numSquaresToEdge[start][i]; j++) {
                const target = start + dirOffsets[i] * (j + 1);
                const targetValue = this.getPiece(target);
                if (targetValue != 0)
                    break;
                const rank = getRankFromSq(target);
                const file = getFileFromSq(target);
                let captures = [];
                for (let s = 0; s < considerSquares.length; s++) {
                    const sq = considerSquares[s];
                    const sqRank = getRankFromSq(sq);
                    const sqFile = getFileFromSq(sq);
                    if (sqRank != rank && sqFile != file) {
                        // death squares are formed
                        const death1 = rank * 8 + sqFile;
                        const death1Value = this.getPiece(death1);
                        const death2 = sqRank * 8 + file;
                        const death2Value = this.getPiece(death2);
                        if (death1Value && !arePiecesSameSide(piece, death1Value)) {
                            // if chameleon, must be capturing a king
                            if (s == 0 || s > 0 && isPieceOfType(death1Value, PieceType.King))
                                captures.push({ sq: death1, captured: death1Value });
                        }
                        if (death2Value && !arePiecesSameSide(piece, death2Value)) {
                            // if chameleon, must be capturing a king
                            if (s == 0 || s > 0 && isPieceOfType(death2Value, PieceType.King))
                                captures.push({ sq: death2, captured: death2Value });
                        }
                    }
                }
                moves.push(new Move(target, start, captures));
            }
        }
    }
    generateStraddlerMoves(start, piece, moves) {
        if (this.isImmobilized(start, piece))
            return;
        // determines number of valid directions the piece can go through
        let canMoveForward = false;
        for (let i = 0; i < 4; i++) {
            // goes through all squares until it hits an edge
            for (let j = 0; j < numSquaresToEdge[start][i]; j++) {
                const target = start + dirOffsets[i] * (j + 1);
                const targetValue = this.getPiece(target);
                if (targetValue != 0)
                    break;
                // straddler can now capture a piece ahead of it, to its left, or to its right (relative to movement)
                const captures = [];
                for (let k = -1; k <= 1; k++) {
                    const d = (i + 4 + k) % 4;
                    const nextTarget = target + dirOffsets[d];
                    const nextTargetValue = this.getPiece(nextTarget);
                    if (numSquaresToEdge[target][d] <= 1) {
                        if (nextTargetValue == 0)
                            canMoveForward = true;
                        continue;
                    }
                    const nextNextTarget = target + dirOffsets[d] * 2;
                    const nextNextTargetValue = this.getPiece(nextNextTarget);
                    // must have a center target and a straddler on the other side for the...
                    // CUSTODIAN CAPTURE.
                    // If any of the encompassing pieces are chameleons, the captured piece must also be a straddler.
                    // must be some of the ugliest code in the whole while world :)
                    const chameleonCapt = isPieceOfType(nextNextTargetValue, PieceType.Chameleon);
                    const canCapture = chameleonCapt && isPieceOfType(nextTargetValue, PieceType.Straddler) || !chameleonCapt && isPieceOfType(nextNextTargetValue, PieceType.Straddler);
                    if (nextTargetValue != 0 && !arePiecesSameSide(piece, nextTargetValue) && arePiecesSameSide(nextNextTargetValue, piece) && canCapture) {
                        captures.push({ sq: nextTarget, captured: nextTargetValue });
                    }
                    else if (nextTargetValue == 0 && k == 0) {
                        canMoveForward = true;
                    }
                }
                moves.push(new Move(target, start, captures));
                if (!canMoveForward) {
                    break;
                }
            }
        }
    }
    // generates moves for a king
    generateKingMoves(start, piece, moves) {
        if (this.isImmobilized(start, piece))
            return;
        // king can team up with its own coordinator to create death squares
        const coordSq = this.getCoordSq(false);
        const coordRank = getRankFromSq(coordSq);
        const coordFile = getFileFromSq(coordSq);
        // see if king can team up with chameleon and capture an enemy coordinator!
        const enemyCoordSq = this.getCoordSq(true);
        const enemyCoordRank = getRankFromSq(enemyCoordSq);
        const enemyCoordFile = getFileFromSq(enemyCoordSq);
        // check all directions
        for (let i = 0; i < dirOffsets.length; i++) {
            if (numSquaresToEdge[start][i] > 0) {
                const target = start + dirOffsets[i];
                const targetValue = this.getPiece(target);
                if (targetValue != 0 && arePiecesSameSide(piece, targetValue)) {
                    continue;
                }
                const rank = getRankFromSq(target);
                const file = getFileFromSq(target);
                const captures = [];
                if (coordSq != 255 && coordRank != rank && coordFile != file) {
                    // death squares are formed
                    const death1 = rank * 8 + coordFile;
                    const death1Value = this.getPiece(death1);
                    const death2 = coordRank * 8 + file;
                    const death2Value = this.getPiece(death2);
                    if (death1Value && !arePiecesSameSide(piece, death1Value)) {
                        captures.push({ sq: death1, captured: death1Value });
                    }
                    if (death2Value && !arePiecesSameSide(piece, death2Value)) {
                        captures.push({ sq: death2, captured: death2Value });
                    }
                }
                // test for king-chameleon death squares
                if (enemyCoordSq != 255) {
                    const thisRank = getRankFromSq(target);
                    const thisFile = getFileFromSq(target);
                    const chamStart = this.turn == Side.White ? 0 : 2;
                    const chamEnd = this.turn == Side.White ? 2 : 4;
                    for (let i = chamStart; i < chamEnd; i++) {
                        if (this.chameleons[i] == 255)
                            break;
                        const rank = getRankFromSq(this.chameleons[i]);
                        const file = getFileFromSq(this.chameleons[i]);
                        // forms death squares, but only against the enemy coordinator.
                        // and there's always only one enemy coordinator.
                        // of course, the king isn't actually forming chameleon death squares if the two are aligned (rank/file)
                        if (rank == enemyCoordRank && thisFile == enemyCoordFile && thisFile != file && thisRank != rank) {
                            captures.push({ sq: enemyCoordSq, captured: this.getPiece(enemyCoordSq) });
                            break;
                        }
                        if (file == enemyCoordFile && thisRank == enemyCoordRank && thisFile != file && thisRank != rank) {
                            captures.push({ sq: enemyCoordSq, captured: this.getPiece(enemyCoordSq) });
                            break;
                        }
                    }
                }
                if (targetValue != 0 && !arePiecesSameSide(piece, targetValue)) {
                    captures.push({ sq: target, captured: targetValue });
                }
                moves.push(new Move(target, start, captures));
            }
        }
    }
    // takes in a list of moves, and gives a list of all legal moves
    filterLegalMoves(moves) {
        return moves.filter((move) => this.isMoveLegal(move));
    }
    // checks if a move is legal
    isMoveLegal(move) {
        this.makeMove(move);
        // if the move causes the current king to stay in check, then it can't be legal
        const attacksKing = this.isAttacked(this.getKingSq(true));
        this.unmakeMove(move);
        return !attacksKing;
    }
    // performs a move on the board. this method assumes that the given move is LEGAL
    // if the move is not legal, then some funny behavior could occur.
    makeMove(move) {
        // update halfmove counter
        this.halfmoves.unshift(this.halfmoves[0] + 1);
        if (move.captures.length > 0)
            this.halfmoves[0] = 0;
        // go through all of the captures
        for (const { sq } of move.captures)
            this.pickup(sq);
        // moves the piece to its designated square, leaving nothing behind
        this.placedown(move.to, this.pickup(move.from));
        // fullmove
        if (isPieceOfSide(this.turn, Side.Black)) {
            this.fullmove++;
        }
        // set turn
        this.nextTurn();
    }
    // un-does a move on the board (make sure that the move being undone is the most recent made move)
    unmakeMove(move) {
        // update halfmove counter
        this.halfmoves.shift();
        // unmove the piece and uncapture whatever it captured.
        this.placedown(move.from, this.pickup(move.to));
        for (const { sq, captured } of move.captures)
            this.placedown(sq, captured);
        // set turn
        this.nextTurn();
        // fullmove
        if (isPieceOfSide(this.turn, Side.Black)) {
            this.fullmove--;
        }
    }
}
//# sourceMappingURL=move-gen.js.map